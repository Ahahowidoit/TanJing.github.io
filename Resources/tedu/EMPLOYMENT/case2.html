
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>CASE</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <script type="text/javascript" src="index.files/jquery.min.js">
    </script>
    <script type="text/javascript" src="index.files/jquery.snippet.js">
    </script>
    <script type="text/javascript" src="index.files/main.js">
    </script>
    <link type="text/css" href="index.files/index.css" rel="Stylesheet" />
    <link type="text/css" href="index.files/jquery.snippet.css" rel="Stylesheet" />
  </head>
  <body>
    <div class="source_style_case">
      <a name="page_top_case" id="top_anchor" />
      <a id="link_top" href="#page_top_case">Top</a>
      <h1>DME EMPLOYMENT DAY02</h1>
      <ol class="index">
        <li>
          <a href="#case1">银行电话营销活动分析</a>
        </li>
        <li>
          <a href="#case2">提高通讯公司问题响应速度</a>
        </li>
      </ol>
      <a name="case1">
      </a>
      <h2>1 银行电话营销活动分析</h2>
      <h3>1.1 问题</h3>
      <p>营销活动以电话为基础，一般，银行的客服人员需要联系客户至少一次，以此确认客户是否将认购该银行的产品（定期存款）。</p>
      <p>数据包含涉及客户ID，年龄，职业，是否有个人贷款，联系次数，上次活动结果等</p>
      <p>本次将以该数据集作为分析样本，用python对客户社会属性、客户存贷款行为、银行营销动作等信息进行分析，目的是刻画客户群体肖像、分析营销动作效果，以便制定银行营销策略</p>
      <h3>1.2 步骤</h3>
      <p>实现此案例需要按照如下步骤进行。</p>
      <p>1）导入需要的环境库</p>
      <p>2）导入医院数据</p>
      <p>3）数据描述分析</p>
      <p>4）营销活动营销分析</p>
      <h3>1.3 代码</h3>
      <p>完整代码如下：</p>
      <pre class="code">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# 显示中文
plt.rcParams['font.sans-serif']='SimHei'
plt.rcParams['axes.unicode_minus']=False
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

data = pd.read_csv('bank-full.csv',sep=';')

data.head()

data.info()

data.columns

data.describe()

data.y.value_counts()

# 完成1-5的分析  

# 1、订购银行产品数据分析

# 创建画布
fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(16,6))
# 绘制饼图
y_pct=data.y.value_counts()*100/len(data)

# 绘制第一个子图
sns.countplot(x='y',data=data,ax=axes[0])

# 绘制第二个子图
axes[1].pie(x=y_pct,autopct='%.1f%%',labels=y_pct.index,
           shadow=True,explode=[0.1,0])

plt.show()

# 2、客户群体—年龄特征

mean=data.age.mean()
median=data.age.median()
mode=data.age.mode().values[0]

plt.figure(figsize=(10,6))
sns.histplot(data=data,x=data.age,kde=True)
plt.axvline(mean,color='r',linestyle='--',label='mean')
plt.axvline(median,color='g',linestyle='--',label='median')
plt.axvline(mode,color='b',linestyle='--',label='mode')
plt.legend()
plt.title('客户群体—年龄分布')
plt.show()

# 3、客户群体—工作种类

data.job.value_counts()

job_pct=data.job.value_counts()*100/len(data)
job_pct

fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(18,6))
axes[0].pie(x=job_pct,autopct='%.2f%%',labels=job_pct.index)
sns.countplot(y='job',data=data,palette='hls',
             ax=axes[1])
plt.show()

# 4、客户群体—教育程度、个人贷款、房贷

data.education.value_counts()

data.loan.value_counts()

data.housing.value_counts()

edu_pct=data.education.value_counts()*100/len(data)
loan_pct=data.loan.value_counts()*100/len(data)
housing_pct=data.housing.value_counts()*100/len(data)

fig,axes=plt.subplots(nrows=1,ncols=3,figsize=(16,6))
axes[0].pie(x=edu_pct,labels=edu_pct.index
            ,autopct='%.2f%%',shadow=True)
axes[0].set_title('job_pie_chart')

axes[1].pie(x=loan_pct,labels=loan_pct.index
            ,autopct='%.2f%%',shadow=True)
axes[1].set_title('loan_pie_chart')

axes[2].pie(x=housing_pct,labels=housing_pct.index
            ,autopct='%.2f%%',shadow=True)
axes[2].set_title('housing_pie_chart')

plt.show()

# 5、前次活动数据分析

poutcome_pct=data.poutcome.value_counts()*100/len(data)
poutcome_pct

fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(16,6))
sns.countplot(x='poutcome',data=data,ax=axes[0])
axes[1].pie(x=poutcome_pct,autopct='%.1f%%',
           shadow=True,labels=poutcome_pct.index)
plt.show()

# 6、数据概况---存款信息

data.balance.describe()

data.balance.plot(kind='hist')

# 7、最后通话时长及活动联系次数分析

# 通话时长
mean_dura=data.duration.mean()
median_dura=data.duration.median()
mode_duna=data.duration.mode().values[0]

# 联系次数
mean_campaign=data.campaign.mean()
median_campaign=data.campaign.median()
mode_campaign=data.campaign.mode().values[0]

fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(16,5))
sns.histplot(data=data,x='duration',kde=True,ax=axes[0])
axes[0].set_title('通话时长')
axes[0].axvline(mean_dura,color='r',linestyle='-',label='mean')
axes[0].axvline(median_dura,color='g',linestyle='-.',label='median')
axes[0].axvline(mode_duna,color='b',linestyle='--',label='mode')
axes[0].legend()

sns.histplot(data=data,x='campaign',kde=True,ax=axes[1])
axes[1].set_title('联系次数')
axes[1].axvline(mean_campaign,color='r',linestyle='-',label='mean')
axes[1].axvline(median_campaign,color='g',linestyle='-.',label='median')
axes[1].axvline(mode_campaign,color='b',linestyle='--',label='mode')
axes[1].legend()
plt.show()

# 8、影响因素分析 -年龄与存款的联系

sns.jointplot(x='age',y='balance',data=data,
             kind='reg')

# 9、年龄、存款、订购银行产品意愿

sns.jointplot(x='age',y='balance',hue='y',data=data)

# 10、职业分析，职业与存款

plt.figure(figsize=(13,6))
sns.stripplot(x=data.job,y=data.balance)
plt.show()

plt.figure(figsize=(12,6))
sns.boxplot(y='job',x='balance',data=data)
plt.show()

# 11、职业与银行订阅产品

plt.figure(figsize=(10,6))
sns.countplot(data=data,y=data.job,hue='y')
plt.show()

data.columns

# 单独分析 管理者
manage=data[(data['job']=='management')]
manage
manage_yes=manage[(manage['y']=='yes')]
manage_yes
fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(16,6))
sns.histplot(manage_yes['marital'],ax=axes[0])
sns.histplot(manage_yes['education'],ax=axes[1])
plt.show()

sns.jointplot(x='age',y='balance',hue='y',data=manage_yes)

data['job'].unique()

# 职业分析 技术人员
tech=data[(data['job']=='technician')]
tech
tech_yes=tech[(tech['y']=='yes')]
tech_yes
fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(16,6))
sns.histplot(tech_yes['marital'],ax=axes[0])
sns.histplot(tech_yes['education'],ax=axes[1])
plt.show()

sns.jointplot(x='age',y='balance',hue='y',data=tech_yes)

data['job'].unique()

# 职业分析 蓝领
bc=data[(data['job']=='blue-collar')]
bc
bc_yes=bc[(bc['y']=='yes')]
bc_yes
fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(16,6))
sns.histplot(bc_yes['marital'],ax=axes[0])
sns.histplot(bc_yes['education'],ax=axes[1])
plt.show()

sns.jointplot(x='age',y='balance',hue='y',data=bc_yes)

# 12、教育水平、存款及订购银行产品

sns.stripplot(x=data.education,y=data.balance,
             hue=data.y,data=data)

# 13、房子贷款、存款和订购银行产品

sns.stripplot(x=data.housing,y=data.balance,hue=data.y)

# 14、影响因素 个人贷款

plt.figure(figsize=(8,6))
sns.stripplot(x='loan',y='balance',hue='y',data=data)

# 15、最后联系日距今时长和通话时长

# sns.jointplot(x='pdays',y='balance',hue='y',data=data)
sns.jointplot(x='duration',y='balance',hue='y',data=data)
</pre>
      <a name="case2">
      </a>
      <h2>2 提高通讯公司问题响应速度</h2>
      <h3>2.1 问题</h3>
      <p>无论从移动用户还是固网宽带用户上，几乎都是三大运营商垄断了整个通讯市场，所以对于任何一个运营商来说，都着重把经历放到维护现有用户上，维护老用户主要是注重用户体验，除了基本服务的保障如网速，通讯信号稳定等（这些技术已经</p>
      <h3>2.2 步骤</h3>
      <p>实现此案例需要按照如下步骤进行。</p>
      <p>1）导入需要的环境库</p>
      <p>2）导入数据</p>
      <p>3）数据描述性分析</p>
      <p>4）探索性分析</p>
      <h3>2.3 代码</h3>
      <p>完整代码如下：</p>
      <pre class="code">import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')
plt.rcParams['font.sans-serif'] = ['SimHei']

data = pd.read_csv("吐槽.csv",encoding="gbk")
data.head()

#1. 对数据进行描述性分析  完整性分析
#2. 根据反馈类型，提取一二三级目录 三级类目去掉[]
#3. 计算响应间隔 回复时间-反馈时间 小时来表示
#4. 平均响应时间

data.info()

data['一级类目']=data['反馈类型'].str.split('-').apply(lambda x:x[0])
data['二级类目']=data['反馈类型'].str.split('-').apply(lambda x:x[1])
data['三级类目']=data['反馈类型'].str.split('-').apply(lambda x:x[2])

data['三级类目']=data['三级类目'].str.replace('[\[\]]','')

data.head(1)

# 计算响应间隔
data.info()

# 修改数据类型
data['反馈时间']=pd.to_datetime(data['反馈时间'])
data['回复时间']=pd.to_datetime(data['回复时间'])

data['响应间隔']=data['回复时间']-data['反馈时间']
# data['响应间隔'].dt.seconds/60/60
data['响应间隔']=data['响应间隔'].dt.seconds/60/60
data['响应间隔'].mean()

data.head(1)

#1. 统计一级类目有多少种  查看响应间隔平均值
#2. 一级类目 二级类目 分类之后 对反馈内容 进行计数，得到top5 查看响应间隔平均值

# 统计一级类目有多少种
data['一级类目'].value_counts()

data.groupby('一级类目')['响应间隔'].mean()

data.groupby(by=['一级类目',
                '二级类目'],as_index=False)['反馈内容'].count().sort_values(by='反馈内容',
                                                                   ascending=False)

data.groupby(by=['一级类目',
                '二级类目'],as_index=False)['响应间隔'].mean().sort_values(by='响应间隔',
                                                                   ascending=False)

data.head(1)

# 类目完整表
# 按照一级类目 二级类目 分组  三级类目去重呈现
# 一级类目  二级类目  三级类目                          

data_problem=data.groupby(by=['一级类目','二级类目'],
            as_index=False)['三级类目'].apply(lambda x:', '.join(set(', '.join(x).split(', '))))     
data_problem.to_csv('problem.csv')

# 1. 分组下的数据 整合变成一个大的str
# 2. 切割变成列表
# 3. 对列表去重变成集合
# 4. 集合再转换为str

# '，'.join(set('，'.join(x).split('，')))

# data_problem  反馈详细数据

# 1. 结构调整 
# 一级类目  二级类目       三级类目
#  其他     IPTV电视包    节目资费高
# 其他     IPTV电视包    操作复杂

# 2. 三级类目出现的次数

data_problem
# 一列变多列
data_三级类目=data_problem['三级类目'].str.split(', ',expand=True)
data_三级类目
# # 多列变多行 堆叠 0：0行
data_三级类目=data_三级类目.stack()
data_三级类目
# # series变成一个表格 再重置行索引
data_三级类目=data_三级类目.to_frame()
data_三级类目=data_三级类目.reset_index()
data_三级类目
data_三级类目.columns=['行号','序号','三级类目']
del data_三级类目['序号']

data_三级类目

data_三级类目

# 主键合并
df=pd.merge(data_problem,data_三级类目,left_index=True,
           right_on='行号')
df
del df['三级类目_x']
del df['行号']

df

# 反馈的问题的详细数据
df.rename(columns={'三级类目_y':'三级类目'},inplace=True)
df

df['标签路径']=df.一级类目+'---&gt;'+df.二级类目+'---&gt;'+df.三级类目
df

data.head(1)

df

# 统计三级类目出现的次数
df['数量']=df.apply(lambda x:((data['一级类目']==x[0])&amp;(data['二级类目']==x[1])&amp;(data['三级类目'].str.contains(x[2]))).sum(),axis=1)
df.sort_values(by='数量',ascending=False)
                  

# 每个人各类问题的处理量
user_data=data.groupby(by=['回复人ID','一级类目',
                 '二级类目'],as_index=False)['三级类目'].count()
user_data[user_data['回复人ID']==1] 

# 修改列名称
user_data.rename(columns={'三级类目':'数量'},
                inplace=True)
user_data
# 
user_data['占比']=user_data.apply(lambda x:x[3]/user_data['数量'][user_data['回复人ID']==x[0]].sum(),
                               axis=1)
user_data
user_data[user_data['回复人ID']==1] 
user_data

user_data.sort_values(by='数量',ascending=False)

# 每个客户 工作量比例数据
pd.pivot_table(data=user_data,index='回复人ID',
              columns=['一级类目','二级类目'],values='占比')

#1. 得到每个人处理速度平均值
#2. 处理快的25% 提取出来 表扬
#3. 处理慢的25% 提取处理 重新培训
#4. 写项目总结

# 得到每个人处理速度平均值
time_sudu=data.groupby('回复人ID',as_index=False)['响应间隔'].mean()
time_sudu

time_sudu['响应间隔'].describe()

# 处理慢的员工
time_sudu[time_sudu['响应间隔']&gt;10.423543].shape
# 处理快的员工
time_sudu[time_sudu['响应间隔']&lt;5.469259].shape
</pre>
    </div>
  </body>
</html>